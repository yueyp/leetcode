<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

        在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

        注意:
        假设字符串的长度不会超过 1010。

        示例 1:

        输入:
        "abccccdd"

        输出:
        7

        解释:
        我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
        */
        /**
        * @param {string} s
        * @return {number}
        */
        /**
 * @param {string} s
 * @return {number}
 */
        var longestPalindrome = function (s) {
            let obj = {}
            for (let i = 0; i < s.length; i++) {
                if (obj[s[i]]) {
                    obj[s[i]]++
                } else {
                    obj[s[i]] = 1
                }
            }
            let num = 0
            Object.keys(obj).map(v => {
                // 若能被2整除，则说明这个字符均能作为回文字符串的元素
                if (obj[v] % 2 === 0) {
                    num += obj[v]
                } else {
                    // 若不能被2整除，那么减去1后肯定能被2整除，
                    num += obj[v] - 1
                }
            })

            return num < s.length ? ++num : num
        };
        // 遍历s，然后将元素放进一个map对象中，若之前有，则num+2，删除map里的该元素.若没有，则往map里增加此元素
        var longestPalindrome = function (s) {
            if(s.length < 2) return s.length
            let map1 = new Map()
            let num = 0
            for (let i = 0; i < s.length; i++) {
                if(map1.get(s[i])){
                    map1.delete(s[i])
                    num += 2
                }else{
                    map1.set(s[i],1)
                }
            }
            return num >= s.length ? num : num + 1
        }
    </script>
</body>
</html>