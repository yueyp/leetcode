<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            多数元素
            给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
            你可以假设数组是非空的，并且给定的数组总是存在多数元素。
        */
        /**
          * @param {number[]} nums
          * @return {number}
          */
        //  方法一
        var majorityElement = function (nums) {
            if (nums.length === 1) return nums[0]
            let obj = {}
            for (let i = 0; i < nums.length; i++) {
                if (obj[nums[i]]) {
                    obj[nums[i]]++
                    if (obj[nums[i]] > nums.length / 2) {
                        return nums[i]
                    }
                } else {
                    obj[nums[i]] = 1
                }
            }
        };
        // 方法二
        var majorityElement = function (nums) {
            nums.sort((a, b) => {
                return a - b
            })
            return nums[Math.floor(nums.length / 2)]
        }
        // 方法三
        /*
        摩尔投票法思路
            候选人(cand_num)初始化为nums[0]，票数count初始化为1。
            当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。
            当票数count为0时，更换候选人，并将票数count重置为1。
            遍历完数组后，cand_num即为最终答案。

            为何这行得通呢？
            投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。
            且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。
            因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。
            这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。

            无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。
        */
        var majorityElement = function (nums) {
            let cand_num = nums[0], count = 1;
            for (let i = 1; i < nums.length; ++i) {
                if (cand_num == nums[i])
                    ++count;
                else if (--count == 0) {
                    cand_num = nums[i];
                    count = 1;
                }
            }
            return cand_num;
        }
        // 方法四
        ////每一轮随机选择一个数字，统计出现次数，因为目标出现频率大于二分之一，所以效率较高
        var majorityElement = function (nums) {
            while (true) {
                let candidate = nums[Math.round(Math.random() * (nums.length - 1))], count = 0;
                for (let n = 0; n < nums.length; n++) {
                    if (nums[n] == candidate)
                        count++;
                }
                if (count > nums.length / 2) return candidate;
            }
            return -1;
        }
        majorityElement([2,3,3])
    </script>
</body>

</html>