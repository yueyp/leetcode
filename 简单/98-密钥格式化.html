<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。

        给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

        给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

        示例 1：

        输入：S = "5F3Z-2e-9-w", K = 4
        输出："5F3Z-2E9W"
        解释：字符串 S 被分成了两个部分，每部分 4 个字符；
             注意，两个额外的破折号需要删掉。
        */
        /**
        * @param {string} S
        * @param {number} K
        * @return {string}
        */
        // 法一，先去掉-，在转换为大写字母，最后进行正则匹配 --- 超出时间限制
        var licenseKeyFormatting = function (S, K) {
            s = s.replace(/-/g, "").toUpperCase()
            let reg = new RegExp(`(\\w{1,${k}})(?=(\\w{${k}})+(?:$))`, "g")
            return s.replace(reg, '$1-')
        };
        // 法二，先去掉-，在转换为大写字母，在反向循环字符串，每隔k插入-，循环到最后一项除外，插入完毕后再反转字符串
        var licenseKeyFormatting = function (s, k) {
            let str = ''
            s = s.replace(/-/g, "").toUpperCase()
            for (let i = s.length - 1, j = 1; i >= 0; i--, j++) {
                if (j % k === 0 && i != 0) {
                    str += s[i] + "-"
                } else {
                    str += s[i]
                }
            }
            return str.split('').reverse().join('')
        }
        // 法三,先去掉-，再转换为大写字母，再转换为数组进行反转，利用reduce进行拼接
        var licenseKeyFormatting = function (s, k) {
            s = s.replace(/-/g, "").toUpperCase()
            if (s.length) {
                return s.split('').reverse().reduce((prev, next, index) => {
                    return ((index % k) ? next : (next + '-')) + prev;
                })
            } else {
                return ""
            }
        }
        console.log(licenseKeyFormatting("5F3Z-2e-9-w", 4))
    </script>
</body>
</html>