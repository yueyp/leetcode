<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。

        示例:

        输入:
        [1,2,3]

        输出:
        3

        解释:
        只需要3次移动（注意每次移动会增加两个元素的值）：

        [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
        */
        /**
        * @param {number[]} nums
        * @return {number}
        */
        var minMoves = function (nums) {
            if ([...new Set(nums)].length === 1) return 0
            let times = 0
            nums.sort((a, b) => {
                return a - b
            })
            console.log(nums)
            while (true) {
                times++
                for (let i = 0; i < nums.length - 1; i++) {
                    nums[i]++
                }
                nums.sort((a, b) => {
                    return a - b
                })
                if ([...new Set(nums)].length === 1) return times
            }

        };

        /*
        首先,我们知道,为了在最小移动内使所有元素相等，我们需要在数组的最大元素之外的所有元素中执行增加。
        因此,在暴力法中，我们扫描整个数组以查找最大值和最小元素。此后，我们将 11 添加到除最大元素之外的所有元素，
        并增加移动数的计数。同样，我们重复相同的过程，直到最大元素和最小元素彼此相等。
        */
        var minMoves = function (nums) {
            let min = 0, max = nums.length - 1, count = 0;
            while (true) {
                for (let i = 0; i < nums.length; i++) {
                    if (nums[max] < nums[i]) {
                        max = i;
                    }
                    if (nums[min] > nums[i]) {
                        min = i;
                    }
                }
                if (nums[max] == nums[min]) {
                    break;
                }
                for (let i = 0; i < nums.length; i++) {
                    if (i != max) {
                        nums[i]++;
                    }
                }
                count++;
            }
            return count;
        }
        /*
            题意可理解位每次让一个值减去1，使得所有的值相等，那理想情况就是每个值最终等于最小值。

            那么题目就转换为所有值减去最小值的和。
        */
        var minMoves = function (nums) {
            let min = Math.min(...nums)
            let count = 0
            for(let i = 0;i < nums.length;i++){
                count += nums[i] - min
            }
            return count
        }
        var minMoves = function (nums) {
        }
        var minMoves = function (nums) {
        }
        console.log(minMoves([3, 2, 1]))
    </script>
</body>
</html>